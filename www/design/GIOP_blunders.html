<!DOCTYPE HTML PUBLIC "-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//EN" "hmpro6.dtd">
<!--
  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 
  Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved.
 
  The contents of this file are subject to the terms of either the GNU
  General Public License Version 2 only ("GPL") or the Common Development
  and Distribution License("CDDL") (collectively, the "License").  You
  may not use this file except in compliance with the License. You can obtain
  a copy of the License at https://glassfish.dev.java.net/public/CDDL+GPL.html
  or glassfish/bootstrap/legal/LICENSE.txt.  See the License for the specific
  language governing permissions and limitations under the License.
 
  When distributing the software, include this License Header Notice in each
  file and include the License file at glassfish/bootstrap/legal/LICENSE.txt.
  Sun designates this particular file as subject to the "Classpath" exception
  as provided by Sun in the GPL Version 2 section of the License file that
  accompanied this code.  If applicable, add the following below the License
  Header, with the fields enclosed by brackets [] replaced by your own
  identifying information: "Portions Copyrighted [year]
  [name of copyright owner]"
 
  Contributor(s):
 
  If you wish your version of this file to be governed by only the CDDL or
  only the GPL Version 2, indicate your decision by adding "[Contributor]
  elects to include this software in this distribution under the [CDDL or GPL
  Version 2] license."  If you don't indicate a single choice of license, a
  recipient has the option to distribute your version of this file under
  either the CDDL, the GPL Version 2 or to extend the choice of license to
  its licensees as provided above.  However, if you add GPL Version 2 code
  and therefore, elected the GPL Version 2 license, then the option applies
  only if the new code is made subject to such option by the copyright
  holder.
-->
<HTML> 
  <HEAD> 
	 <TITLE>GIOP Blunders</TITLE>
	 <META NAME="Generator" CONTENT="vim (Vi IMproved editor; http://www.vim.org/)">
	 <META NAME="Author" CONTENT="">
	 <META NAME="Copyright" CONTENT="Copyright (C) May 18, 2004 ">
	 <LINK REV="made" HREF="mailto:"> 
  </HEAD> 
  <BODY> 
	 <H1 ALIGN="CENTER">GIOP Blunders</H1> 
	 <P> </P> <HR WIDTH="75%"> 
	 <P> Last Modified: <I>May 18, 2004</I> </P> 
	 <P> Version: 1.6 </P> 
	 <ADDRESS> <A HREF="mailto:ken.cavanaugh@sun.com">&lt;Ken Cavanaugh&gt;</A>
		</ADDRESS>
	 <P> It's interesting to take a look at the errors (and outright blunders)
		that were committed in the design of GIOP. I am just looking at GIOP and some
		items directly from CORBA, rather than all of CORBA. Here's my list: </P>
	 <OL>
		<LI><B>Lack of separate session layer.</B> This needs to top the list,
		  because this is probably the worst of the blunders. Addressing this problem
		  would allow us to introduce very powerful session-dependent compression, which
		  would substantially reduce the size of the messages. It would clean up other
		  problems as well, such as assigning an FVD to a session. </LI>
		<LI><B>Inadequate versioning support.</B> We need to be able to version
		  the protocol separately from the encoding. </LI>
		<LI><B>Use of padding in CDR.</B> The alignment rules force complications
		  in the code, and don't really buy anything for performance. </LI>
		<LI><B>Use of indirection instead of labelling for references to shared
		  data.</B> Correctly computing the indirections affects the code in many places,
		  due to the presence of fragmentation and encapsulation. It would be simpler to
		  just reference the position of the item directly, instead of an indirection to
		  the item. </LI>
		<LI><B>Inadequate semantics for location forward.</B> We tried to fix this 
                once with the location forward permanent idea, but that broke down into
                semantic difficulties.  The whole area of what a client should do when a 
                request completes other than normally is underspecified.
		</LI>
		<LI><B>Overly complex wide character support.</B>
		</LI>
		<LI><B>IDL has become too complex yet remains insufficiently
		  expressive.</B> There are a lot of areas here that can be criticized, because
		  every mistake in IDL directly translates to a problem in GIOP. Here's my list: 
		  <OL> 
			 <LI><B>Strings and characters should all be unicode.</B> </LI>
			 <LI><B>Unions should not exist.</B> </LI>
			 <LI><B>Structs, Exceptions, and ValueTypes should be unified.</B>
				</LI>
			 <LI><B>Truncatable valuetypes are a mistake and should not exist.</B>
				</LI>
			 <LI><B>XML should be a first-class citizen in IDL.</B> </LI>
			 <LI><B>Sequence and Array should not both exist.</B> </LI>
		  </OL></LI>
		<LI><B>Too hard to get GIOP through a firewall.</B> Of course, any number
                of ORBs (including some in the past at Sun) have done things like base64
                encoding through HTTP.  The problem is that no real standard exists.
                The OMG firewall spec efforts aimed at changing firewalls to handle IIOP,
                which was not possible.  Instead, a standardized means (even if slower) to
                encode IIOP in a firewall friendly manner would make more sense.  
		</LI>
		<LI><B>IOR design is more complex than needed.</B> We end up mostly
                just needing opaque target object information, plus an open ended and
                extensible list of transport end point addresses. A single level list
                structure would handle this nicely.
		</LI>
		<LI><B>Request ID belongs in the GIOP header.</B>  This simplifies the
                transport dispatch code, because reading a GIOP message requires first 
                reading the fixed 12 byte header, which given enough information to
                read the rest of the message.  Since the request ID is needed very
                early in the request processing, it would be nicer to simply include
                it in the GIOP header (even in those cases where it is not needed).
		</LI>
		<LI><B>Fix an endianess choice and be done with it.</B> I've actually 
                changed my mind about this.  Even in Java, it turns out that there are
                significant marshalling efficiencies that are possible if the byte order
                matches the native platform byte order.  Receiver makes right is still the
                correct choice, and I think GIOP is about right here.
		</LI>
		<LI><B>Encapsulations require versioning.</B> In fact, multiple parts
                of the GIOP protocol require versioning, notably encoding and protocol
                (in PEPt terms), which really should be versioned separately.
		</LI>
		<LI><B>Repository IDs should always be meaningful.</B> This should be
                required in all cases, rather than allowing users to specify arbitrary
                repository IDs in an IDL definition.
		</LI>
		<LI><B>Chunking is a bad idea.</B> Instead, introduce enough meta-data so
		  that it is always possible to unmarshal the data, even if the type is unknown.
		  </LI>
		<LI><B>Encapsulating complex typecodes is not needed.</B>
		</LI>
		<LI>It's almost too easy to pick on, but <B>Bidirectional GIOP is a mess,
		  and is not getting any better.</B>
		</LI>
		<LI><B>Clients should be able to determine whether to locate or not.</B>
		</LI>
		<LI><B>Clients should be able to determine when to cache a location
		  forward.</B>
		</LI>
		<LI><B>Client behavior for multiple endpoints and location forward is
		  underspecified.</B>
		</LI> 
	 </OL> </BODY>
</HTML>
